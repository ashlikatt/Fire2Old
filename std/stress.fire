import something
import something2 as s2;

@Save
let allPlayers = Set<UUID>();

fn func1() return 2;

@Unsafe
fn func2(a: Num, b: Num = 0): Int {
    let c = 2                           // a is type Int
    let d: Num = 1;

    if (c > a || c > b) c = a;
    else if (d > a) d = a;
    else a = c + d;

    return a + b * c / d;
}

fn func3(a: List<Num>): Num {
    let smallest = 0;
    for (elem in a)
        if (elem > smallest)
            smallest = elem;
    return smallest;
}



trait Iterator<T> {
    fn hasNext(): bool;
    fn next(): T;
}

@Iterator(/* Stuff~! */)
struct Grid() : Iterator<Loc> {
    curX: Int,
    curY: Int,
    curZ: Int
    startX: Int,
    startY: Int,
    startZ: Int,
    endX: Int,
    endY: Int,
    endZ: Int

    fn hasNext(self): bool {
        return self.curX<self.endX && self.curY<self.endY && self.curZ<self.endZ;
    }

    fn next(self): Loc {
        let out = Loc(self.curX, self.curY, self.curZ);
        self.curX += 1;
        if (self.curX > self.endX) {
            self.curX = self.startX;
            self.curY += 1;
            if (self.curY > self.endY) {
                self.curY = self.startY;
                self.curZ += 1;
                if (self.curZ > self.endZ) {
                    self.curZ = 0;
                }
            }
        }
        return out;
    }

    // RETHINK THIS!
    fn Grid(sX: Int, sY: Int, sZ: Int, eX: Int, eY: Int, eZ: Int) {
        self.startX = sX;
        self.startY = sY;
        self.startZ = sZ;
        self.endX = eX;
        self.endY = eY;
        self.endZ = eZ;
        self.curX = self.startX;
        self.curY = self.startY;
        self.curZ = self.startZ;
    }
}

enum Gender: String {
    F = "Female",
    M = "Male",
    O = "Other",
}

