// Handles +
trait Add<T, R> {
    fn add(self, other: T): R;
}

// Handles -
trait Subtract<T, R> {
    fn subtract(self, other: T): R;
}

// Handles *
trait Multiply<T, R> {
    fn multiply(self, other: T): R;
}

// Handles /
trait Divide<T, R> {
    fn divide(self, other: T): R;
}

// Handles %
trait Modulo<T, R> {
    fn modulo(self, other: T): R;
}

// Handles ==, !=, >, <, >=, and <=
trait Comparable<T> {
    fn compare(self, other: T): Num;
    fn isLess(self, other: T): Bool {
        return self.compare(other) < 0
    }
    fn isGreater(self, other: T): Bool {
        return self.compare(other) > 0
    }
    fn isLessEq(self, other: T): Bool {
        return self.compare(other) <= 0
    }
    fn isGreaterEq(self, other: T): Bool {
        return self.compare(other) >= 0
    }
    fn isEqual(self, other: T): Bool {
        return self.compare(other) == 0
    }
    fn isNotEqual(self, other: T): Bool {
        return self.compare(other) != 0
    }
}

// Handles accessing
trait Accessible<T, R> {
    fn access(self, key: T): R;
    fn assign(self, key: T, val: R);
}


// Handles ||
trait Or<T, R> {
    fn or(self, other: T): R;
}
// Handles &&
trait And<T, R> {
    fn and(self, other: T): R;
}
// Handles !
trait Not<T> {
    fn not(self): T;
}